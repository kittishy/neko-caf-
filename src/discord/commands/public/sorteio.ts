import { CommandBuilder, CommandRunOptions } from '@constatic/core';
import { ApplicationCommandOptionType, EmbedBuilder, ButtonBuilder, ButtonStyle, ActionRowBuilder, ComponentType, ButtonInteraction, TextChannel, GuildMember, ColorResolvable } from 'discord.js';
import mongoose from 'mongoose';
import { setTimeout } from 'node:timers/promises';

// Schema do MongoDB para os sorteios
const GiveawaySchema = new mongoose.Schema({
  messageId: { type: String, required: true },
  channelId: { type: String, required: true },
  guildId: { type: String, required: true },
  hostId: { type: String, required: true },
  prize: { type: String, required: true },
  description: { type: String, default: '' },
  winners: { type: Number, default: 1 },
  endAt: { type: Date, required: true },
  participants: { type: [String], default: [] },
  ended: { type: Boolean, default: false },
});

// Model do MongoDB
const GiveawayModel = mongoose.model('Giveaway', GiveawaySchema);

// Fun√ß√£o para formatar a dura√ß√£o
function parseDuration(duration: string): number {
  const match = duration.match(/^(\d+)([hdwm])$/);
  if (!match) return 0;

  const value = parseInt(match[1]);
  const unit = match[2];

  const multipliers: Record<string, number> = {
    h: 60 * 60 * 1000, // horas
    d: 24 * 60 * 60 * 1000, // dias
    w: 7 * 24 * 60 * 60 * 1000, // semanas
    m: 30 * 24 * 60 * 60 * 1000, // meses (aproximadamente)
  };

  return value * multipliers[unit];
}

// Fun√ß√£o para criar o embed do sorteio
function createGiveawayEmbed(
  prize: string,
  description: string,
  endAt: Date,
  hostId: string,
  winners: number,
  participants: string[]
) {
  const embed = new EmbedBuilder()
    .setTitle(`üéâ SORTEIO: ${prize}`)
    .setDescription(description || 'Sem descri√ß√£o fornecida.')
    .setColor('#FF5733' as ColorResolvable)
    .addFields(
      { name: '‚è∞ Final', value: `<t:${Math.floor(endAt.getTime() / 1000)}:R>`, inline: true },
      { name: 'üëë Organizador', value: `<@${hostId}>`, inline: true },
      { name: 'üèÜ Vencedores', value: winners.toString(), inline: true },
      { name: 'üë• Participantes', value: participants.length.toString(), inline: true }
    )
    .setFooter({ text: 'Clique no bot√£o abaixo para participar!' })
    .setTimestamp();

  return embed;
}

// Fun√ß√£o para criar o embed de vit√≥ria
function createWinnerEmbed(prize: string, hostId: string, winners: string[]) {
  const embed = new EmbedBuilder()
    .setTitle(`üéä SORTEIO FINALIZADO: ${prize}`)
    .setDescription(`Parab√©ns aos vencedores!`)
    .setColor('#33FF57' as ColorResolvable)
    .addFields(
      { name: 'üèÜ Vencedores', value: winners.length > 0 ? winners.map(id => `<@${id}>`).join('\n') : 'Nenhum participante v√°lido.', inline: false },
      { name: 'üëë Organizador', value: `<@${hostId}>`, inline: true },
    )
    .setFooter({ text: 'Obrigado a todos que participaram!' })
    .setTimestamp();

  return embed;
}

// Fun√ß√£o para finalizar o sorteio
async function endGiveaway(messageId: string, channelId: string, guildId: string) {
  const giveaway = await GiveawayModel.findOne({
    messageId,
    channelId,
    guildId,
    ended: false,
  });

  if (!giveaway) return;

  const channel = global.client.channels.cache.get(channelId) as TextChannel;
  if (!channel) return;

  try {
    const message = await channel.messages.fetch(messageId);
    if (!message) return;

    // Atualizar o status do sorteio
    giveaway.ended = true;

    // Selecionar os vencedores
    const participants = giveaway.participants;
    const winnerCount = Math.min(giveaway.winners, participants.length);
    const winners: string[] = [];

    // Algoritmo para selecionar vencedores aleat√≥rios sem repeti√ß√£o
    if (participants.length > 0) {
      const shuffled = [...participants].sort(() => 0.5 - Math.random());
      winners.push(...shuffled.slice(0, winnerCount));
    }

    // Enviar embed com os vencedores
    const winnerEmbed = createWinnerEmbed(giveaway.prize, giveaway.hostId, winners);
    await message.reply({ embeds: [winnerEmbed] });

    // Desativar bot√£o do sorteio
    const row = new ActionRowBuilder<ButtonBuilder>()
      .addComponents(
        new ButtonBuilder()
          .setCustomId(`giveaway-join-${messageId}`)
          .setLabel(`Participar (${participants.length})`)
          .setEmoji('üéâ')
          .setStyle(ButtonStyle.Secondary)
          .setDisabled(true)
      );

    // Atualizar a mensagem original
    await message.edit({
      embeds: [
        EmbedBuilder.from(message.embeds[0])
          .setTitle(`üéâ SORTEIO FINALIZADO: ${giveaway.prize}`)
          .setColor('#808080' as ColorResolvable)
      ],
      components: [row]
    });

    // Salvar os vencedores no banco de dados
    await giveaway.save();

    // Avisar os vencedores
    if (winners.length > 0) {
      const winnerMention = winners.map(id => `<@${id}>`).join(' ');
      await channel.send({
        content: `Parab√©ns ${winnerMention}! Voc√™s ganharam: **${giveaway.prize}**!`,
        allowedMentions: { users: winners }
      });
    }
  } catch (error) {
    console.error('Erro ao finalizar sorteio:', error);
  }
}

// Constru√ß√£o do comando
export default new CommandBuilder()
  .setName('sorteio')
  .setDescription('Gerencia sorteios no servidor')
  .addSubcommand(subcommand =>
    subcommand
      .setName('criar')
      .setDescription('Cria um novo sorteio')
      .addStringOption(option =>
        option.setName('premio')
          .setDescription('O pr√™mio do sorteio')
          .setRequired(true)
      )
      .addStringOption(option =>
        option.setName('duracao')
          .setDescription('Dura√ß√£o do sorteio (1h, 1d, 1w, 1m)')
          .setRequired(true)
      )
      .addIntegerOption(option =>
        option.setName('vencedores')
          .setDescription('Quantidade de vencedores')
          .setRequired(false)
          .setMinValue(1)
          .setMaxValue(10)
      )
      .addStringOption(option =>
        option.setName('descricao')
          .setDescription('Descri√ß√£o do sorteio')
          .setRequired(false)
      )
  )
  .addSubcommand(subcommand =>
    subcommand
      .setName('reroll')
      .setDescription('Sorteia novos vencedores para um sorteio')
      .addStringOption(option =>
        option.setName('mensagem_id')
          .setDescription('ID da mensagem do sorteio')
          .setRequired(true)
      )
  )
  .addSubcommand(subcommand =>
    subcommand
      .setName('finalizar')
      .setDescription('Finaliza um sorteio manualmente')
      .addStringOption(option =>
        option.setName('mensagem_id')
          .setDescription('ID da mensagem do sorteio')
          .setRequired(true)
      )
  )
  .addSubcommand(subcommand =>
    subcommand
      .setName('listar')
      .setDescription('Lista todos os sorteios ativos no servidor')
  )
  .setDMPermission(false)
  .setDefaultMemberPermissions(0)
  .run(async ({ interaction, client }: CommandRunOptions) => {
    if (!interaction.inCachedGuild()) return;

    const subcommand = interaction.options.getSubcommand();

    if (subcommand === 'criar') {
      const prize = interaction.options.getString('premio', true);
      const durationStr = interaction.options.getString('duracao', true);
      const winnerCount = interaction.options.getInteger('vencedores') || 1;
      const description = interaction.options.getString('descricao') || '';

      // Validar a dura√ß√£o
      const duration = parseDuration(durationStr);
      if (duration <= 0) {
        return interaction.reply({
          content: 'Formato de dura√ß√£o inv√°lido. Use, por exemplo: 1h, 6h, 1d, 3d, 1w, 1m',
          ephemeral: true
        });
      }

      // Calcular a data de fim
      const endAt = new Date(Date.now() + duration);

      // Responder ao usu√°rio que o sorteio est√° sendo criado
      await interaction.deferReply();

      try {
        // Criar o embed do sorteio
        const embed = createGiveawayEmbed(
          prize,
          description,
          endAt,
          interaction.user.id,
          winnerCount,
          []
        );

        // Criar o bot√£o de participa√ß√£o
        const row = new ActionRowBuilder<ButtonBuilder>()
          .addComponents(
            new ButtonBuilder()
              .setCustomId(`giveaway-join-placeholder`)
              .setLabel('Participar (0)')
              .setEmoji('üéâ')
              .setStyle(ButtonStyle.Primary)
          );

        // Enviar a mensagem do sorteio
        const reply = await interaction.followUp({
          embeds: [embed],
          components: [row],
          fetchReply: true
        });

        // Atualizar o ID do bot√£o com o ID da mensagem
        const updatedRow = new ActionRowBuilder<ButtonBuilder>()
          .addComponents(
            new ButtonBuilder()
              .setCustomId(`giveaway-join-${reply.id}`)
              .setLabel('Participar (0)')
              .setEmoji('üéâ')
              .setStyle(ButtonStyle.Primary)
          );

        await reply.edit({ components: [updatedRow] });

        // Salvar o sorteio no banco de dados
        const giveaway = new GiveawayModel({
          messageId: reply.id,
          channelId: interaction.channelId,
          guildId: interaction.guildId,
          hostId: interaction.user.id,
          prize,
          description,
          winners: winnerCount,
          endAt,
          participants: [],
        });

        await giveaway.save();

        // Agendar o fim do sorteio
        setTimeout(async () => {
          await endGiveaway(reply.id, interaction.channelId, interaction.guildId);
        }, duration);

      } catch (error) {
        console.error('Erro ao criar sorteio:', error);
        await interaction.followUp({
          content: 'Ocorreu um erro ao criar o sorteio.',
          ephemeral: true
        });
      }
    } else if (subcommand === 'reroll') {
      const messageId = interaction.options.getString('mensagem_id', true);
      
      await interaction.deferReply();

      // Buscar o sorteio no banco de dados
      const giveaway = await GiveawayModel.findOne({
        messageId,
        guildId: interaction.guildId,
        ended: true,
      });

      if (!giveaway) {
        return interaction.followUp({
          content: 'Sorteio n√£o encontrado ou ainda n√£o finalizado.',
          ephemeral: true
        });
      }

      // Verificar se h√° participantes
      if (giveaway.participants.length === 0) {
        return interaction.followUp({
          content: 'N√£o √© poss√≠vel refazer o sorteio pois n√£o h√° participantes.',
          ephemeral: true
        });
      }

      try {
        // Selecionar novos vencedores
        const participants = giveaway.participants;
        const winnerCount = Math.min(giveaway.winners, participants.length);
        const winners: string[] = [];

        // Algoritmo para selecionar vencedores aleat√≥rios
        const shuffled = [...participants].sort(() => 0.5 - Math.random());
        winners.push(...shuffled.slice(0, winnerCount));

        // Criar embed de novos vencedores
        const winnerEmbed = createWinnerEmbed(giveaway.prize, giveaway.hostId, winners);
        winnerEmbed.setTitle(`üéä SORTEIO REFEITO: ${giveaway.prize}`);

        await interaction.followUp({ embeds: [winnerEmbed] });

        // Avisar os novos vencedores
        const channel = interaction.channel as TextChannel;
        if (winners.length > 0) {
          const winnerMention = winners.map(id => `<@${id}>`).join(' ');
          await channel.send({
            content: `Novo sorteio realizado! Parab√©ns ${winnerMention}! Voc√™s ganharam: **${giveaway.prize}**!`,
            allowedMentions: { users: winners }
          });
        }

      } catch (error) {
        console.error('Erro ao refazer sorteio:', error);
        await interaction.followUp({
          content: 'Ocorreu um erro ao refazer o sorteio.',
          ephemeral: true
        });
      }
    } else if (subcommand === 'finalizar') {
      const messageId = interaction.options.getString('mensagem_id', true);
      
      await interaction.deferReply({ ephemeral: true });

      // Verificar se o sorteio existe e ainda n√£o terminou
      const giveaway = await GiveawayModel.findOne({
        messageId,
        guildId: interaction.guildId,
        ended: false,
      });

      if (!giveaway) {
        return interaction.followUp({
          content: 'Sorteio n√£o encontrado ou j√° finalizado.',
          ephemeral: true
        });
      }

      // Verificar permiss√µes (apenas o criador ou administradores podem finalizar)
      if (giveaway.hostId !== interaction.user.id && !interaction.memberPermissions.has('Administrator')) {
        return interaction.followUp({
          content: 'Voc√™ n√£o tem permiss√£o para finalizar este sorteio.',
          ephemeral: true
        });
      }

      try {
        // Finalizar o sorteio
        await endGiveaway(messageId, interaction.channelId, interaction.guildId);
        await interaction.followUp({
          content: 'Sorteio finalizado com sucesso!',
          ephemeral: true
        });
      } catch (error) {
        console.error('Erro ao finalizar sorteio:', error);
        await interaction.followUp({
          content: 'Ocorreu um erro ao finalizar o sorteio.',
          ephemeral: true
        });
      }
    } else if (subcommand === 'listar') {
      await interaction.deferReply();

      // Buscar todos os sorteios ativos do servidor
      const giveaways = await GiveawayModel.find({
        guildId: interaction.guildId,
        ended: false,
      }).sort({ endAt: 1 });

      if (giveaways.length === 0) {
        return interaction.followUp({
          content: 'N√£o h√° sorteios ativos neste servidor.',
          ephemeral: true
        });
      }

      // Criar embed com a lista
      const embed = new EmbedBuilder()
        .setTitle('üéâ Sorteios Ativos')
        .setColor('#FF5733' as ColorResolvable)
        .setDescription('Lista de todos os sorteios ativos neste servidor:')
        .setTimestamp();

      giveaways.forEach((giveaway, index) => {
        embed.addFields({
          name: `${index + 1}. ${giveaway.prize}`,
          value: `üèÜ **Vencedores:** ${giveaway.winners}\n‚è∞ **T√©rmino:** <t:${Math.floor(giveaway.endAt.getTime() / 1000)}:R>\nüë• **Participantes:** ${giveaway.participants.length}\nüìù **ID:** \`${giveaway.messageId}\``,
          inline: false
        });
      });

      await interaction.followUp({ embeds: [embed] });
    }
  })
  .setExecuteButtonPress(async ({ interaction, client }) => {
    if (!interaction.isButton() || !interaction.inCachedGuild()) return;
    
    const customId = interaction.customId;
    
    // Verificar se √© um bot√£o de participa√ß√£o de sorteio
    if (!customId.startsWith('giveaway-join-')) return;
    
    // Extrair o ID da mensagem do sorteio
    const messageId = customId.replace('giveaway-join-', '');
    
    // Buscar o sorteio no banco de dados
    const giveaway = await GiveawayModel.findOne({
      messageId,
      channelId: interaction.channelId,
      guildId: interaction.guildId,
      ended: false,
    });
    
    if (!giveaway) {
      return interaction.reply({
        content: 'Este sorteio n√£o existe ou j√° foi finalizado.',
        ephemeral: true
      });
    }
    
    const userId = interaction.user.id;
    const isParticipating = giveaway.participants.includes(userId);
    
    // Atualizar participa√ß√£o
    if (isParticipating) {
      // Remover participa√ß√£o
      giveaway.participants = giveaway.participants.filter(id => id !== userId);
      await interaction.reply({
        content: `Voc√™ desistiu de participar do sorteio **${giveaway.prize}**.`,
        ephemeral: true
      });
    } else {
      // Adicionar participa√ß√£o
      giveaway.participants.push(userId);
      await interaction.reply({
        content: `Voc√™ est√° participando do sorteio **${giveaway.prize}**. Boa sorte!`,
        ephemeral: true
      });
    }
    
    // Salvar altera√ß√µes
    await giveaway.save();
    
    // Atualizar o bot√£o com o novo contador
    const row = new ActionRowBuilder<ButtonBuilder>()
      .addComponents(
        new ButtonBuilder()
          .setCustomId(`giveaway-join-${messageId}`)
          .setLabel(`Participar (${giveaway.participants.length})`)
          .setEmoji('üéâ')
          .setStyle(ButtonStyle.Primary)
      );
    
    // Atualizar o embed
    const message = await interaction.message.fetch();
    const updatedEmbed = EmbedBuilder.from(message.embeds[0])
      .spliceFields(3, 1, { name: 'üë• Participantes', value: giveaway.participants.length.toString(), inline: true });
    
    await message.edit({
      embeds: [updatedEmbed],
      components: [row]
    });
  });